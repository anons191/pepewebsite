/*! html2canvas 1.4.1 | Copyright (c) 2022 Niklas von Hertzen | MIT License */
(function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :
    typeof define === 'function' && define.amd ? define(factory) :
    (global = typeof globalThis !== 'undefined' ? globalThis : global || self, global.html2canvas = factory());
}(this, (function () { 'use strict';

    // This is a functional implementation of html2canvas for your meme generator
    function html2canvas(element, options) {
        return new Promise((resolve, reject) => {
            try {
                console.log("Starting html2canvas conversion");
                const canvas = document.createElement('canvas');
                const ctx = canvas.getContext('2d');
                
                // Set canvas dimensions to match the element
                const rect = element.getBoundingClientRect();
                canvas.width = rect.width;
                canvas.height = rect.height;
                
                // Draw background color
                ctx.fillStyle = '#222';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                
                // Create an image for the background
                const bgImg = new Image();
                
                // Extract URL from the backgroundImage style
                let bgUrl = '';
                const bgImageStyle = window.getComputedStyle(element).backgroundImage;
                console.log("Background image style:", bgImageStyle);
                
                if (bgImageStyle && bgImageStyle !== 'none') {
                    bgUrl = bgImageStyle.replace(/url\(['"]?(.*?)['"]?\)/i, '$1');
                    console.log("Extracted background URL:", bgUrl);
                } else {
                    console.log("No background image found in computed style");
                    // Try to get it directly from the style attribute
                    bgUrl = element.style.backgroundImage.replace(/url\(['"]?(.*?)['"]?\)/i, '$1');
                    console.log("Extracted from style attribute:", bgUrl);
                }
                
                if (!bgUrl) {
                    console.error("Could not find background image URL");
                    drawTextOnly();
                    return;
                }
                
                bgImg.onload = () => {
                    console.log("Background image loaded:", bgImg.width, "x", bgImg.height);
                    
                    // Draw the background image preserving aspect ratio
                    const imgRatio = bgImg.width / bgImg.height;
                    const canvasRatio = canvas.width / canvas.height;
                    
                    let drawWidth, drawHeight, drawX, drawY;
                    
                    if (imgRatio > canvasRatio) {
                        // Image is wider than container
                        drawHeight = canvas.height;
                        drawWidth = drawHeight * imgRatio;
                        drawX = (canvas.width - drawWidth) / 2;
                        drawY = 0;
                    } else {
                        // Image is taller than container
                        drawWidth = canvas.width;
                        drawHeight = drawWidth / imgRatio;
                        drawX = 0;
                        drawY = (canvas.height - drawHeight) / 2;
                    }
                    
                    ctx.drawImage(bgImg, drawX, drawY, drawWidth, drawHeight);
                    console.log("Background image drawn");
                    
                    // Now draw the text elements
                    drawTextElements();
                };
                
                bgImg.onerror = (e) => {
                    console.error("Error loading background image:", e);
                    drawTextOnly();
                };
                
                // Ensure we handle both direct URLs and data URLs
                if (bgUrl.startsWith('data:')) {
                    bgImg.src = bgUrl;
                } else {
                    // For relative URLs, make sure we have the full path
                    if (bgUrl.startsWith('/')) {
                        bgImg.src = window.location.origin + bgUrl;
                    } else if (!bgUrl.startsWith('http')) {
                        // If it's a relative path, convert to absolute
                        const baseUrl = window.location.href.substring(0, window.location.href.lastIndexOf('/') + 1);
                        bgImg.src = baseUrl + bgUrl;
                    } else {
                        bgImg.src = bgUrl;
                    }
                }
                
                // Function to draw just the text if background fails
                function drawTextOnly() {
                    console.log("Drawing text only (no background)");
                    drawTextElements();
                }
                
                // Function to draw all text elements
                function drawTextElements() {
                    const textElements = element.querySelectorAll('.text-element');
                    console.log("Drawing text elements:", textElements.length);
                    
                    textElements.forEach((textEl, index) => {
                        console.log(`Drawing text element ${index+1}:`, textEl.textContent);
                        
                        // Get computed style
                        const textStyle = window.getComputedStyle(textEl);
                        
                        // Get position relative to container
                        const textRect = textEl.getBoundingClientRect();
                        const containerRect = element.getBoundingClientRect();
                        
                        const x = textRect.left - containerRect.left + (textRect.width / 2);
                        const y = textRect.top - containerRect.top;
                        
                        // Set text styles
                        ctx.fillStyle = textStyle.color;
                        ctx.font = `${textStyle.fontWeight} ${textStyle.fontSize} ${textStyle.fontFamily}`;
                        ctx.textAlign = 'center';
                        
                        // Apply text shadow for "stroke" effect if present
                        if (textStyle.textShadow && textStyle.textShadow !== 'none') {
                            ctx.shadowColor = 'black';
                            ctx.shadowBlur = 2;
                            ctx.shadowOffsetX = 2;
                            ctx.shadowOffsetY = 2;
                        }
                        
                        // Split and draw multi-line text
                        const lines = textEl.innerText.split('\\n');
                        const fontSize = parseInt(textStyle.fontSize);
                        const lineHeight = fontSize * 1.2;
                        
                        lines.forEach((line, i) => {
                            const yPos = y + (i * lineHeight) + fontSize;
                            
                            // Draw "stroke" effect by drawing the text in black offset in different directions
                            if (textEl.style.textShadow && textEl.style.textShadow.includes('black')) {
                                ctx.fillStyle = 'black';
                                ctx.fillText(line, x + 2, yPos + 2); // bottom right
                                ctx.fillText(line, x - 2, yPos - 2); // top left
                                ctx.fillText(line, x + 2, yPos - 2); // top right
                                ctx.fillText(line, x - 2, yPos + 2); // bottom left
                                ctx.fillStyle = textStyle.color;
                            }
                            
                            ctx.fillText(line, x, yPos);
                        });
                        
                        // Reset shadow
                        ctx.shadowColor = 'transparent';
                        ctx.shadowBlur = 0;
                        ctx.shadowOffsetX = 0;
                        ctx.shadowOffsetY = 0;
                    });
                    
                    console.log("All elements drawn, resolving promise");
                    resolve(canvas);
                }
                
            } catch (err) {
                console.error("html2canvas critical error:", err);
                reject(err);
            }
        });
    }

    return html2canvas;
})));
